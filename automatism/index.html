<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta charset="utf-8" />
    <script src="p5.min.js"></script>
    <script>let tokenData = { "tokenId": "281000184", "hash": "0xa9d03745b9b1b88b753d3c4310b68153e3399557982ac2c3d69cc6a63452c887" }</script>
    <script>var $jscomp = $jscomp || {}; $jscomp.scope = {}; $jscomp.createTemplateTagFirstArg = function (a) { return a.raw = a }; $jscomp.createTemplateTagFirstArgWithRaw = function (a, b) { a.raw = b; return a }; $jscomp.arrayIteratorImpl = function (a) { var b = 0; return function () { return b < a.length ? { done: !1, value: a[b++] } : { done: !0 } } }; $jscomp.arrayIterator = function (a) { return { next: $jscomp.arrayIteratorImpl(a) } }; $jscomp.makeIterator = function (a) { var b = "undefined" != typeof Symbol && Symbol.iterator && a[Symbol.iterator]; return b ? b.call(a) : $jscomp.arrayIterator(a) };
        var seed, R, FPS = 60, ratio = .8, goldenRatio = 1.618, roundedCornerParams, stopTime, firstStop, backgroundColor, dark, lastStop, collisionCount, strokeCount, qtree, colDark = "#111111", colLight = "#F1F1F1", internalFeatures, externalFeatures;
        function calculateFeatures(a) {
            a = R.random_int(60, 100); var b = R.random_int(2 * a, 5 * a), c = [0, 1, 2, 3, 4, 5, 6][R.weighted_index([.3, .1, .15, .1, .1, .15, .1])], g = R.random_num(0, R.random_num(.85, 1)), d = [0, 1, 2, 3, 4, 5, 6, 7, 8][R.weighted_index([.05, .15, .2, .08, .06, .07, .15, .17, .07])], h = R.random_num(.005, .015), e = Math.max(R.random_num(.9, R.random_num(9.5, 10)), 1), f = h * e, l = R.random_num(1.25, 2.5), k = [.05, .1][R.weighted_index([1 / 3, 2 / 3])], m = [0, 1, 2][R.weighted_index([.1, .75, .15])], n, p, q, r, t;[3, 4, 5].includes(c) && (n = {
                x: R.random_num(0,
                    1) * width, y: R.random_num(0, 1) * height
            });[1, 2].includes(c) && (p = R.random_int(0, 360));[0].includes(d) && (q = R.random_int(0, 360));[0, 1].includes(d) && (r = R.random_int(0, 360));[2].includes(d) && (t = R.random_int(0, 360)); internalFeatures = { minLength: a, maxLength: b, startAngleStyle: c, angleChangeProb: g, strokeClearance: l, strokeVariation: e, baseStrokeSize: h, maxStrokeSize: f, margin: k, finishing: m, palette: d, origin: n, angle: p, backgroundHue: q, backdropHue: r, lightboardHue: t }; externalFeatures = {
                "Stroke Size": getFeatureString("Stroke Size",
                    f * e), "Color Palette": getFeatureString("Color Palette", d), "Directional Influence": getFeatureString("Directional Influence", c), Proximity: getFeatureString("Proximity", l), "Stroke Variance": getFeatureString("Stroke Variance", e), "Stoic Strokes": getFeatureString("Stoic Strokes", g), Margin: getFeatureString("Margin", k), Finishing: getFeatureString("Finishing", m)
            }; console.log("w: " + width + ", h: " + height); console.table(externalFeatures); return externalFeatures
        }
        function getFeatureString(a, b) {
            switch (a) {
                case "Color Palette": switch (b) {
                    case 0: return push(), colorMode(HSB, 360, 100, 100, 255), backgroundColor = color(internalFeatures.backdropHue, 70, 90), background(color(internalFeatures.backgroundHue, 70, 90)), pop(), drawBackdrop(internalFeatures.backdropHue), colors = [colDark], "Colorful Keith"; case 1: colors = [colDark]; if (R.random_bool(.5)) return background(colLight), colorMode(HSB, 360, 100, 100, 255), backgroundColor = color(internalFeatures.backdropHue, 70, 90), drawBackdrop(internalFeatures.backdropHue),
                        "Backdrop"; background(colDark); colorMode(HSB, 360, 100, 100, 255); backgroundColor = color(internalFeatures.backdropHue, 70, 90); dark = !0; drawBackdrop(internalFeatures.backdropHue); return "Backlit"; case 2: backgroundColor = colDark; background(backgroundColor); dark = !0; switch ([0, 1, 2][R.weighted_index([.3, .6, .1])]) {
                            case 0: return push(), colorMode(HSB, 360, 100, 100, 255), colors = [color(internalFeatures.lightboardHue, 70, 90)], pop(), internalFeatures.palette = 2.1, "Lightboard"; case 1: return colors = [colLight], internalFeatures.palette =
                                2.2, "Liquid Chalk"; case 2: return backgroundColor = color("#030304"), background(backgroundColor), colors = ["#181818", "#2b2c34", "#2c343b", "#454952"], internalFeatures.palette = 2.3, "All Black Errthang"
                        }break; case 3: return backgroundColor = colLight, background(backgroundColor), colors = "#ae3754 #ed9639 #f2d344 #365254 #365254 #a1ad00 #a1ad00 #868894 #9ad3e5 #3257a9 #1c703f #b23178 #aa88c5 #aa88c5 #ea7841 #4ea3e0 #b62730".split(" "), "Henri Gradi"; case 4: return R.random_bool(.2) ? (backgroundColor = colLight, background(backgroundColor),
                            colors = [colDark]) : (backgroundColor = colDark, background(backgroundColor), dark = !0, colors = [colLight]), "Goodness Grayscale"; case 5: return backgroundColor = colDark, background(backgroundColor), dark = !0, "Nineties Neon"; case 6: if (R.random_bool(.5)) { colors = ["#e5bb99", "#a31917"]; var c = R.random_int(0, colors.length - 1); backgroundColor = colors[c]; background(backgroundColor); colors.splice(c, 1); colors.push(colDark); return "Cave" } backgroundColor = color("#d4d6d0"); background(backgroundColor); colors = ["#282a2f", "#282a2f",
                                "#faffff", "#cb1f38"]; return "Urban"; case 7: backgroundColor = colLight; background(backgroundColor); colors = [colDark]; switch ([0, 1, 2][R.weighted_index([.55, .35, .1])]) { case 0: return "Classic Keith"; case 1: return colors = colors.concat([colDark, colDark, "#dd0100"]), "Red Marker"; case 2: return colors = ["#23120b", "#225095", "#fdb827", "#dd0100"], "Mondy" }break; case 8: return backgroundColor = "#abb99c", background(backgroundColor), colors = "#737c6b #737c6b #737c6b #414538 #bed1c1 #dee9da".split(" "), "Palm"
                }break; case "Directional Influence": switch (b) {
                    case 0: return "Random";
                    case 1: return "Diagonal"; case 2: return "Unidirectional"; case 3: return "Zoom"; case 4: return "Radial"; case 5: return "Spiral"; case 6: return "Flow"
                }break; case "Stroke Size": if (.017 >= b) return stopTime = 3.2, "Skinny"; if (.017 < b && .24 >= b) return stopTime = 2.4, "Bold"; if (.24 < b && .7 >= b) return stopTime = 1.6, "Thicc"; stopTime = .8; return "Supa Chonky"; case "Proximity": return 1.7 >= b ? "Intimate" : 1.7 < b && 2.3 >= b ? "Relaxed" : "Gimme some space"; case "Stroke Variance": return 2.5 >= b ? "Consistent" : 2.5 < b && 6 >= b ? "Varied" : "Dramatic"; case "Stoic Strokes": return .88 >=
                    b ? !1 : !0; case "Margin": switch (b) { case .05: return stopTime *= 1.5, "Thin"; case .1: return "Wide" }break; case "Finishing": switch (b) { case 0: return "Clean"; case 1: return roundedCornerParams = [.15, .45], "Rough"; case 2: return roundedCornerParams = [0, .25], "Raw" }
            }
        } function setup() { frameRate(FPS); initPiece() }
        function initPiece() {
            loop(); clear(); resetMatrix(); var a, b; window.innerHeight <= window.innerWidth ? (a = Math.max(window.innerHeight, 1) * ratio, b = Math.max(window.innerHeight, 1)) : (a = Math.max(window.innerWidth, 1), b = Math.max(window.innerWidth, 1) / ratio); canvas = createCanvas(a, b); frameCount = 0; drawSpeed = 1; looping = !0; lastStop = firstStop = finalStroke = !1; steps = strokeCount = collisionCount = 0; newPoints.length = 0; pressurePoints.length = 0; R = new Random; seed = parseInt(tokenData.hash.slice(0, 16), 16); noiseSeed(seed); noiseDetail(3); console.log("Hash: " + tokenData.hash); a = new Rectangle(0,
                0, width, height); qtree = new QuadTree(a, 4); noStroke(); rectMode(CORNER); calculateFeatures(tokenData); drawBorder(); setNewStart()
        } var currX, currY, currAngle, angleChange, steps, maxSteps, currColor, newColor, newPoints = []; function drawBackdrop(a) { push(); colorMode(HSB, 360, 100, 100, 255); fill(a, 70, 90); rect(internalFeatures.margin * height * .8, internalFeatures.margin * height * .8, width - internalFeatures.margin * height * 1.6, height - internalFeatures.margin * height * 1.6); pop() }
        function drawBorder() {
            push(); var a = [2.1, 2.2, 2.3, 4, 6, 8].includes(internalFeatures.palette) ? R.random_choice(colors) : colDark; fill(a); ellipseMode(CENTER); rectMode(CENTER); a = []; for (var b = [], c = [], g = [], d = .81 * internalFeatures.margin; d < 1 * ratio - .81 * internalFeatures.margin; d += .001) {
                for (var h = d * height, e = map(noise(h / width * 4.5), 0, 1, .0085, .017), f = internalFeatures.margin * height * .78 + map(noise(h / width), 0, 1, 0, .008) * height, l = 0; 2 > l; l++)if (resetMatrix(), 0 == l ? translate(h, f) : translate(width - h, height - f), 0 == internalFeatures.finishing) ellipse(0,
                    0, e * height); else { rotate(radians(R.random_num(-15, 15))); var k = R.random_num(e * height * roundedCornerParams[0], e * height * roundedCornerParams[1]); rect(0, 0, e * height * .7, e * height, k, k, k, k) } c.push({ x: h, y: f, size: 1.25 * e }); g.push({ x: width - h, y: height - f, size: 1.25 * e })
            } for (d = .81 * internalFeatures.margin; d < 1 - .81 * internalFeatures.margin; d += .001) {
                h = d * height; e = map(noise(h / width * 4.5), 0, 1, .0085, .017); f = internalFeatures.margin * height * .78 + map(noise(h / height), 0, 1, 0, .008) * height; for (l = 0; 2 > l; l++)resetMatrix(), 0 == l ? translate(f,
                    h) : translate(width - f, height - h), 0 == internalFeatures.finishing ? ellipse(0, 0, e * height) : (rotate(radians(R.random_num(-15, 15))), k = R.random_num(e * height * roundedCornerParams[0], e * height * roundedCornerParams[1]), rect(0, 0, e * height, e * height * .7, k, k, k, k)); a.push({ x: f, y: h, size: 1.25 * e }); b.push({ x: width - f, y: height - h, size: 1.25 * e })
            } addPoints(a.slice()); addPoints(b.slice()); addPoints(c.slice()); addPoints(g.slice()); pop()
        }
        function setNewStart() {
            strokeCount++; steps = 0; newPoints.length = 0; pressurePoints.length = 0; maxSteps = R.random_int(internalFeatures.minLength, internalFeatures.maxLength); do currX = R.random_dec() * ratio * height, currY = R.random_dec() * height; while (pointOutsideMargin({ x: currX, y: currY })); switch (internalFeatures.startAngleStyle) {
                case 0: currAngle = R.random_int(0, 360); break; case 1: currAngle = internalFeatures.angle + 90 * R.random_int(0, 1); break; case 2: currAngle = internalFeatures.angle; break; case 3: push(); translate(internalFeatures.origin.x,
                    internalFeatures.origin.y); currAngle = 180 + degrees(atan2(currY - internalFeatures.origin.y, currX - internalFeatures.origin.x)); pop(); break; case 4: push(); translate(internalFeatures.origin.x, internalFeatures.origin.y); currAngle = 90 + degrees(atan2(currY - internalFeatures.origin.y, currX - internalFeatures.origin.x)); pop(); break; case 5: push(); translate(internalFeatures.origin.x, internalFeatures.origin.y); currAngle = 360 + 360 * (1 - goldenRatio) + degrees(atan2(currY - internalFeatures.origin.y, currX - internalFeatures.origin.x));
                    pop(); break; case 6: currAngle = map(noise(currX / width, currY / height), 0, 1, 0, 360)
            }4 == internalFeatures.palette ? [3, 4, 5].includes(internalFeatures.startAngleStyle) ? dark ? (currColor = color(map(dist(internalFeatures.origin.x, internalFeatures.origin.y, currX, currY), 0, height, 15, 230)), nextColor = color(map(dist(internalFeatures.origin.x, internalFeatures.origin.y, currX, currY), 0, height, 15, 230))) : (currColor = color(map(dist(internalFeatures.origin.x, internalFeatures.origin.y, currX, currY), 0, height, 240, 25)), nextColor = color(map(dist(internalFeatures.origin.x,
                internalFeatures.origin.y, currX, currY), 0, height, 240, 25))) : (currColor = color(R.random_int(15, 230)), nextColor = color(R.random_int(15, 230))) : 5 == internalFeatures.palette ? (colorMode(HSB, 360, 100, 100, 255), currColor = color(R.random_int(0, 360), 60, 90), nextColor = color(R.random_int(0, 360), 60, 90)) : (currColor = color(colors[R.random_int(0, colors.length - 1)]), nextColor = color(colors[R.random_int(0, colors.length - 1)]))
        } var pressurePoints = [], drawSpeed, maxReps = 200;
        function draw() {
            drawSpeed < maxReps && (drawSpeed = Math.min(Math.pow(2, 1 * frameCount - 10), maxReps)); for (var a = 0; a < drawSpeed; a++) {
                steps++; var b = currX, c = currY, g = [0, 2, 3, 4, 5][R.weighted_index([.14, .14, .42, .21, .07])]; 0 == steps % round(maxSteps / g) && (currAngle += [R.random_num(80, 100), R.random_num(120, 180), R.random_num(40, 50)][R.weighted_index([.95, .02, .03])] * R.random_choice([-1, 1])); if (R.random_bool(internalFeatures.angleChangeProb)) angleChange = (Math.sin(.01 * steps) - Math.sin(.01 * steps)) / 2; else {
                    var d = R.random_num(.5,
                        1), h = R.random_num(1, goldenRatio); angleChange = R.random_num(1, 1 + 3 * (1 - internalFeatures.angleChangeProb)) * Math.sin(1E-4 * strokeCount + .01 * steps * d) + Math.sin(1E-4 * strokeCount + .01 * steps * h)
                } currAngle += angleChange; size = map(noise(b / width * 3, c / height * 3), 0, 1, internalFeatures.baseStrokeSize, internalFeatures.maxStrokeSize); b = currX + .1 * size * height * Math.cos(radians(currAngle)); c = currY + .1 * size * height * Math.sin(radians(currAngle)); if (0 >= b || b >= width || 0 >= c || c >= height) currAngle += 90; if (!lastStop || finalStroke) if (!finalStroke &&
                    (steps >= maxSteps || pointOutsideMargin({ x: b, y: c }) || pointsCollide({ x: b, y: c, size: size * internalFeatures.strokeClearance }))) {
                        if ("0" != internalFeatures.finishing && ![2.3, 4].includes(internalFeatures.palette)) for (b = 0; b < pressurePoints.length; b++) {
                            push(); 10 > brightness(pressurePoints[b].col) ? (c = color("#BBB"), blendMode(SCREEN), c.setAlpha(3)) : dark ? (c = color("#FFF"), c.setAlpha(90 < brightness(pressurePoints[b].col) ? 100 : 5), blendMode(HARD_LIGHT)) : (c = color("#000"), c.setAlpha(15), blendMode(SOFT_LIGHT)); fill(c); for (c = 0; c <
                                pressurePoints[b].shape.length; c++)resetMatrix(), translate(pressurePoints[b].x, pressurePoints[b].y), rotate(radians(pressurePoints[b].rot)), rect(pressurePoints[b].shape[c][0], pressurePoints[b].shape[c][1], pressurePoints[b].shape[c][2], pressurePoints[b].shape[c][3], 1.75 * pressurePoints[b].shape[c][4], 1.75 * pressurePoints[b].shape[c][5], 1.75 * pressurePoints[b].shape[c][6], 1.75 * pressurePoints[b].shape[c][7]); pop()
                        } addPoints(newPoints.slice()); setNewStart()
                } else {
                    [3, 4].includes(internalFeatures.palette) ? (d =
                        round((maxSteps - steps) / maxSteps, 2), fillColor = lerpColor(currColor, nextColor, d)) : fillColor = currColor; fill(fillColor); d = h = void 0; 0 == internalFeatures.finishing ? (h = map(noise(b / width * 2, c / height * 2), 0, 1, -5, 5), d = map(noise(strokeCount, .025 * steps), 0, 1, .8, 1)) : 1 == internalFeatures.finishing ? (h = map(noise(b / width * 3, c / height * 3), 0, 1, -70, 70) + R.random_num(-2, 2), d = map(noise(strokeCount, .05 * steps), 0, 1, 1.25, 1.7)) : 2 == internalFeatures.finishing && (h = map(noise(b / width * 4, c / height * 4), 0, 1, -160, 160) + R.random_num(-15, 15), d = map(noise(strokeCount,
                            .03 * steps), 0, 1, .5, 4) + R.random_num(-.25, .25)); resetMatrix(); translate(b, c); rotate(radians(h)); if ("0" == internalFeatures.finishing) ellipse(0, 0, size * height * .9, size * height); else {
                                rectMode(CENTER); var e = map(noise(strokeCount + .2 * steps, 10), 0, 1, roundedCornerParams[0], roundedCornerParams[1]), f = map(noise(strokeCount + .2 * steps, 20), 0, 1, roundedCornerParams[0], roundedCornerParams[1]), l = map(noise(strokeCount + .2 * steps, 30), 0, 1, roundedCornerParams[0], roundedCornerParams[1]), k = map(noise(strokeCount + .2 * steps, 40), 0, 1, roundedCornerParams[0],
                                    roundedCornerParams[1]); blendMode(BLEND); e = [[size * height / 20, 0, size * height * .65, size * height * d / 1.85, size * height * e * 2, size * height * f, size * height * l, size * height * k * 2], [0, size * height / 8, size * height * .7, size * height * d / 1.6, size * height * e, size * height * f * 2, size * height * l * 2, size * height * k]]; for (f = 0; f < e.length; f++)rect(e[f][0], e[f][1], e[f][2], e[f][3], e[f][4], e[f][5], e[f][6], e[f][7]); (3 > steps % round(maxSteps / g) || steps >= maxSteps - 2 && steps < maxSteps) && pressurePoints.push({ x: b, y: c, size: size, shape: e, rot: h, col: fillColor }); g = noise(strokeCount,
                                        .1 * steps); if (.3 < g && .6 > g) {
                                            push(); rotate(radians(currAngle - h - 90)); g = R.random_int(1, 2 == internalFeatures.finishing ? 6 : 4); for (h = 1; h < g; h++)e = R.random_num(.325, .45 / g), fill(R.random_bool(.3) ? backgroundColor : fillColor), 1 == internalFeatures.finishing ? R.random_bool(.7) ? ellipse(size * height * d * e, 0, size * height * R.random_num(.035, .055), size * height * R.random_num(.015, .55)) : ellipse(size * height * d * R.random_num(.23, .25), size * height * R.random_num(.01, .04), size * height * R.random_num(.04, .08), size * height * R.random_num(.04, .08)) :
                                                2 == internalFeatures.finishing && (f = R.random_num(size * height * roundedCornerParams[0], size * height * roundedCornerParams[1]), R.random_bool(.95) ? rotate(radians(R.random_num(-5, 5))) : rotate(radians(R.random_num(-80, 100))), rect(size * height * d * e, 0, size * height * R.random_num(.035, .045), size * height * R.random_num(.015, .75), f, f, f, f), R.random_bool(.1) ? rect(-size * height * d * e, 0, size * height * R.random_num(.035, .045), size * height * R.random_num(.015, .55), f, f, f, f) : rect(size * height * d * R.random_num(.23, .25), size * height * R.random_num(.01,
                                                    .04), size * height * R.random_num(.06, .1), size * height * R.random_num(.06, .1), f, f, f, f)); pop()
                                        }
                            } newPoints.push({ x: b, y: c, size: size * internalFeatures.strokeClearance }); currX = b; currY = c
                }
            } if (frameCount >= FPS * stopTime && !firstStop) for (noLoop(), looping = !1, firstStop = !0, console.log("First stop reached. Press 'D' to attempt filling in more space (if available). The piece will reassemble in 60 seconds."), a = window.setTimeout(initPiece, 6E4); a--;)window.clearTimeout(a); else lastStop && !finalStroke && (noLoop(), looping = !1, console.log("Space filled."))
        }
        function pointOutsideMargin(a) { return a.x <= internalFeatures.margin * height || a.x >= width - internalFeatures.margin * height || a.y <= internalFeatures.margin * height || a.y >= height * (1 - internalFeatures.margin) } function pointsCollide(a) { var b = new Circle(a.x, a.y, a.size); (b = qtree.query(b).some(function (c) { return distSquared(c.x, c.y, a.x, a.y) <= a.size * height * a.size * height })) ? (collisionCount++, 2E4 == collisionCount && (lastStop = !0)) : collisionCount = 0; return b } function distSquared(a, b, c, g) { a = c - a; b = g - b; return a * a + b * b }
        function addPoints(a) { for (var b = 0; b < a.length; b++)0 != b && 0 != b % 7 && b != a.length - 1 || qtree.insert(a[b]) } var looping = !0, finalStroke = !1; function keyPressed() { 68 === keyCode ? (looping ? console.log("Paused.") : firstStop && !lastStop && console.log("Space filling..."), looping ? noLoop() : loop(), looping = !looping) : 70 === keyCode && lastStop && !finalStroke ? (console.log("Initiating Rogue Stroke."), finalStroke = !0, loop(), looping = !0) : 82 == keyCode ? initPiece() : 83 == keyCode && saveCanvas() }
        var QuadTree = function (a, b) { this.boundary = a; this.capacity = b; this.points = []; this.divided = !1 };
        QuadTree.prototype.subdivide = function () { var a = this.boundary.x, b = this.boundary.y, c = this.boundary.w, g = this.boundary.h, d = new Rectangle(a + c / 2, b, c / 2, g / 2); this.northeast = new QuadTree(d, this.capacity); d = new Rectangle(a, b, c / 2, g / 2); this.northwest = new QuadTree(d, this.capacity); d = new Rectangle(a + c / 2, b + g / 2, c / 2, g / 2); this.southeast = new QuadTree(d, this.capacity); a = new Rectangle(a, b + g / 2, c / 2, g / 2); this.southwest = new QuadTree(a, this.capacity); this.divided = !0 };
        QuadTree.prototype.insert = function (a) { if (!this.boundary.contains(a)) return !1; if (this.points.length < this.capacity) return this.points.push(a), !0; this.divided || this.subdivide(); if (this.northeast.insert(a) || this.northwest.insert(a) || this.southeast.insert(a) || this.southwest.insert(a)) return !0 };
        QuadTree.prototype.query = function (a, b) { b || (b = []); if (this.boundary.intersects(a)) { for (var c = $jscomp.makeIterator(this.points), g = c.next(); !g.done; g = c.next())g = g.value, a.contains(g) && b.push(g); this.divided && (this.northwest.query(a, b), this.northeast.query(a, b), this.southwest.query(a, b), this.southeast.query(a, b)); return b } }; var Rectangle = function (a, b, c, g) { this.x = a; this.y = b; this.w = c; this.h = g };
        Rectangle.prototype.contains = function (a) { return a.x >= this.x - this.w && a.x < this.x + this.w && a.y >= this.y - this.h && a.y < this.y + this.h }; Rectangle.prototype.intersects = function (a) { return !(a.x - a.w > this.x + this.w || a.x + a.w < this.x - this.w || a.y - a.h > this.y + this.h || a.y + a.h < this.y - this.h) }; var Circle = function (a, b, c) { this.x = a; this.y = b; this.r = c * height * 2; this.rSquared = this.r * this.r }; Circle.prototype.contains = function (a) { return distSquared(this.x, this.y, a.x, a.y) <= this.rSquared };
        var Random = function () { this.useA = !1; var a = function (b) { var c = parseInt(b.substr(0, 8), 16), g = parseInt(b.substr(8, 8), 16), d = parseInt(b.substr(16, 8), 16), h = parseInt(b.substr(24, 8), 16); return function () { c |= 0; g |= 0; d |= 0; h |= 0; var e = (c + g | 0) + h | 0; h = h + 1 | 0; c = g ^ g >>> 9; g = d + (d << 3) | 0; d = d << 21 | d >>> 11; d = d + e | 0; return (e >>> 0) / 4294967296 } }; this.prngA = new a(tokenData.hash.substr(2, 32)); this.prngB = new a(tokenData.hash.substr(34, 32)); for (a = 0; 1E6 > a; a += 2)this.prngA(), this.prngB() };
        Random.prototype.random_dec = function () { return (this.useA = !this.useA) ? this.prngA() : this.prngB() }; Random.prototype.random_num = function (a, b) { return a + (b - a) * this.random_dec() }; Random.prototype.random_int = function (a, b) { return Math.floor(this.random_num(a, b + 1)) }; Random.prototype.random_bool = function (a) { return this.random_dec() < a }; Random.prototype.random_choice = function (a) { return a[this.random_int(0, a.length - 1)] };
        Random.prototype.weighted_choice = function (a) { var b = [], c; for (c in a) b = b.concat(Array(a[c][1]).fill(a[c][0])); return this.random_choice(b) }; Random.prototype.weighted_index = function (a) { for (var b = 0, c = 0; c < a.length; c++)b += a[c]; b *= this.random_dec(); for (c = 0; c < a.length; c++) { if (b < a[c]) return c; b -= a[c] } return a.length - 1 };</script>
    <style type="text/css">
        html {
            height: 100%;
        }

        body {
            min-height: 100%;
            margin: 0;
            padding: 0;
        }

        canvas {
            padding: 0;
            margin: auto;
            display: block;
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
        }
    </style>
</head>

</html>